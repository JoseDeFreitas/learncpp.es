# 02.07 Programas con varios archivos de código

<details>
    <summary>Información del archivo</summary>

| Autor en inglés | Traductor al español | Fecha de creación | Última modificación |
| --------------- | -------------------- | ----------------- | ------------------- |
| Alex            | José De Freitas      | 02/06/2007        | 26/12/2020          |

</details>

#### **Índice**

1. [Añadir archivos a tu proyecto](#añadir-archivos-a-tu-proyecto)
2. [Un ejemplo de un programa con múltiples archivos](#un-ejemplo-de-un-programa-con-múltiples-archivos)
3. [¡Algo salió mal!](#algo-salió-mal)
4. [Resumen](#resumen)
5. [Prueba](#prueba)

## Añadir archivos a tu proyecto

Mientras que nuestros programas van creciendo es común querer repartir el contenido en varios
archivos para que todo el código esté más organizado y pueda ser reutilizado con facilidad.
Una ventaja de trabajar con un IDE es que estos hacen que trabajar con múltiples archivos sea
más fácil. Ya sabes cómo crear proyectos de un solo archivo. Es muy fácil añadir nuevos
archivos a un proyecto existente.

> **Mejores prácticas**
>
> Cuando añadas nuevos archivos de código en tu proyecto, agrega *.cpp* como extensión.

> **Para usuarios de Visual Studio**
>
> En Visual Studio, haz clic derecho en la carpeta *Source Files* en la ventana de
> *Solution Explorer* y elige *Add > New Item...*.
> **INSERTE IMAGEN**
> Asegúrate de que está *C++ File (.cpp)* seleccionado. Nombra al nuevo archivo y verás cómo
> se agrega a tu proyecto.
> **INSERTE IMAGEN**
> Nota: Si creas un nuevo archivo desde el menú *File* en vez de desde tu proyecto desde
> *Solution Explorer* el archivo nuevo no se añadirá a tu proyecto automáticamente. En este
> caso tendrás que añadirlo de forma manual. Para hacerlo simplemente haz clic derecho en
> *Source Files* en *Solution Explorer*, elige *Add > Existing Item* y selecciona tu archivo.
>
> Ahora, cuando compiles tu programa, podrás ver que el compilador devuelve el nombre de tu
> archivo.

> **Para usuarios de Code::Blocks**
>
> En Code::Blocks ve al menú *File* y elige *New > File...*.
> **INSERTE IMAGEN**
> En el diálogo *New from template* selecciona *C/C++ source* y haz clic en *Go*.
> **INSERTE IMAGEN**
> Puede que veas un nuevo diálogo de bienvenida a *C/C++ source*; si te aparece, haz clic en
> *Next*.
> **INSERTE IMAGEN**
> En la siguiente página selecciona "C++" y haz clic en *Next*.
> **INSERTE IMAGEN**
> Ahora nombra al nuevo archivo (no olvides la extensión *.cpp*) y haz clic en el botón *All*
> para asegurarte de que todos los objetivos están seleccionados. Luego haz clic en *Finish*.
> **INSERTE IMAGEN**
> Ahora, cuando compiles tu programa, podrás ver que el compilador devuelve el nombre de tu
> archivo.

> **Para usuario de GCC/G++**
>
> Desde la línea de comandos puedes crear archivos adicionales, usando tu editor favorito, y
> nombrándolos posteriormente. Cuando compiles tu programa necesitarás incluir todos los
> archivos de código relevantes en el comando de compilación. Por ejemplo:
> `g++ main.cpp add.cpp -o main`, donde *main.cpp* y *add.cpp* son los nombres de tus archivos
> de código y *main* es el nombre del archivo final.

## Un ejemplo de un programa con múltiples archivos

En la [lección 02.06](/Contenido/Cap%C3%ADtulo%2002%20Fundamentos%20de%20C%2B%2B%20-%20Funciones%20y%20archivos/02.06%20Declaraciones%20y%20definiciones%20de%20futuro.md)
vimos un programa de un solo archivo que no compila:
```cpp
#include <iostream>
 
int main()
{
    std::cout << "La suma de 3 y 4 es: " << add(3, 4) << '\n';
    return 0;
}
 
int add(int x, int y)
{
    return x + y;
}
```

Cuando el compilador llega a la llamada a la función *add* en la línea 5 de *main* este no
sabe qué es *add* porque no definimos *add* sino en la línea 9. Las soluciones que te
enseñamos fueron: reordenar las funciones (poniendo *add* primero) y usar una declaración
de futuro para *add*.

Veamos ahora un programa con más de un archivo.

add.cpp
```cpp
int add(int x, int y)
{
    return x + y;
}
```

main.cpp
```cpp
#include <iostream>
 
int main()
{
    std::cout << "La suma de 3 y 4 es: " << add(3, 4) << '\n'; // compile error
    return 0;
}
```

Tu compilador decidirá si compilar *add.cpp* o *main.cpp* primero. De cualquier manera
*main.cpp* compilará, haciendo que el compilador devuelva el mismo error:
```
main.cpp(5) : error C3861: 'add': identifier not found
```

La razón de este error en este programa es igual al error en el otro programa: cuando el
compilador llega a la línea 5 de *main.cpp* este no sabe qué es *add*.

Recuerda que el compilador compila cada archivo de manera individual. El compilador no sabe
sobre el contenido de otros archivos de código ni recuerda lo que ha visto en archivos de
código compilados previamente. A pesar de que puede que el compilador haya visto la definición
de *add* antes (si compiló *add.cpp* primero), no recuerda haberlo hecho.

Esta visibilidad limitada y la memoria a corto plazo es una característica intencional. El
propósito es que si los archivos compartes nombres iguales de funciones o variables el
programa puede compilar correctamente sin devolver ningún error de nombres. Te enseñaremos
un ejemplo de un error como este en la próxima lección.

Las soluciones que tenemos disponibles son las mismas que antes: poner la definición de la
función *add* antes de la función *main* o escribir una declaración de futuro. En este caso,
debido a que la función *add* está en otro archivo, no podemos reordenar las funciones.

La mejor solución es usar una declaración de futuro.

main.cpp (con una declaración de futuro)
```cpp
#include <iostream>
 
int add(int x, int y); // declaración necesaria para que main.cpp sepa que add() es una función declarada en otro archivo
 
int main()
{
    std::cout << "La suma de 3 y 4 es: " << add(3, 4) << '\n';
    return 0;
}
```

add.cpp (igual que antes)
```cpp
int add(int x, int y)
{
    return x + y;
}
```

Cuando el compilador esté compilando *main.cpp* sabrá qué es el identificador *add* y hará
su trabajo sin problemas. El enlazador conectará la llamada a la función *add* en *main.cpp* a
la definición de la función *add* en *add.cpp*.

Gracias a este método podemos darle a los archivos acceso a las funciones definidas en algún
otro archivo.

Intenta compilar *add.cpp* y *main.cpp* con una declaración de futuro. Si obtienes un error
del enlazador asegúrate de que añadiste *add.cpp* en tu proyecto y de que el comando de
compilación está escrito correctamente.

## ¡Algo salió mal!

Hay muchas cosas que pueden salir mal la primera vez que trabajas con múltiples archivos.
Si hiciste el intento del ejemplo anterior y obtuviste un error, intenta lo siguiente:
1. Si obtienes un error de compilación debido a que *add* no está definido en *main* es
probable que te olvidaste de la declaración de futuro para la función *add* en el archivo
*main.cpp*
2. Si obtienes un error del enlazador debido a que *add* no está definido, por ejemplo:
    1. La razón más probable es que *add.cpp* no está añadido en tu proyecto de manera
    correcta. Cuando compiles tu programa debes ver que el compilador devuelve tanto el nombre
    de *main.cpp* como el de *add.cpp*. Si solo ves *main.cpp* entonces el problema es que
    *add.cpp* no se está compilando. Si estás usando Visual Studio o Code::Blocks deberías
    ver *add.cpp* en *Solution Explorer*/panel del proyecto en la parte izquierda del IDE.
    Si no lo ves, haz clic derecho en tu proyecto y añade el archivo; compila de nuevo. Si
    estás compilando a través de la línea de comandos no te olvides de incluir tanto
    *main.cpp* como *add.cpp* en el comando de compilación.
    2. Es posible que añadiste *add.cpp* al pryecto equivocado.
    3. Es posible que el archivo no está configurado para compilar o enlazar. Revisa las
    propiedades del archivo y asegúrate de que está configurado para compilar y enlazar. En
    Code::Blocks hay dos casillas separadas para estas dos opciones. En Visual Studio hay una
    opción llamada "*exclude from build*" que debe estar configurada a "no" o en blanco.
3. No escribas `#include "add.cpp"` desde *main.cpp*. Esto hará que el compilador agregue el
contenido de *add.cpp* directamente en *main.cpp* en vez de tratarlos como archivos separados.

## Resumen

Cuando el compilador compila un programa con múltiples archivos este compilará los archivos
sin seguir un orden específico. Además, el compilador compila cada archivo de manera
individual, sin saber qué hay en los otros archivos.

Trabajaremos mucho con múltiples archivo cuando entremos en la parte de la programación
orientada a objetos, por lo que es bueno entender desde ahora cómo añadir y compilar
archivos en tu proyecto.

Recordatorio: cuando creas un nuevo archivo de código (.cpp) necesitarás añadirlo a tu
proyecto para que pueda ser compilado.

## Prueba

**Pregunta 1**

Separa el siguiente programa en dos archivos (*main.cpp* e *input.cpp*). *main.cpp* debe
contener la función *main*, mientras que *input.cpp* debe contener la función *getInteger*.

<details>
    <summary>Mostrar pista</summary>
    No te olvides de que necesitarás una declaración de futuro en main.cpp para la función getInteger().
</details>

```cpp
#include <iostream>
 
int getInteger()
{
	std::cout << "Escribe un entero: ";
	int x{};
	std::cin >> x;
	return x;
}
 
int main()
{
	int x{ getInteger() };
	int y{ getInteger() };
 
	std::cout << x << " + " << y << " es " << x + y << '\n';
	return 0;
}
```

<details>
    <summary>Mostrar solución</summary>
input.cpp

    #include <iostream> // necesitamos iostream ya que lo usamos en este archivo
 
    int getInteger()
    {
	    std::cout << "Escribe un entero: ";
	    int x{};
	    std::cin >> x;
	    return x;
    }

main.cpp

    #include <iostream> // necesitamos iostream ya que lo usamos en este archivo
 
    int getInteger(); // declaración de futuro a la función getInteger
 
    int main()
    {
	    int x{ getInteger() };
	    int y{ getInteger() };
 
	    std::cout << x << " + " << y << " is " << x + y << '\n';
        return 0;
    }
</details>

---

**[Lección anterior](/Contenido/Cap%C3%ADtulo%2002%20Fundamentos%20de%20C%2B%2B%20-%20Funciones%20y%20archivos/02.06%20Declaraciones%20y%20definiciones%20de%20futuro.md)** - **[Contenido](https://github.com/JoseDeFreitas/learncpp.es#contenido)** - **[Lección siguiente](/Contenido/Cap%C3%ADtulo%2002%20Fundamentos%20de%20C%2B%2B%20-%20Funciones%20y%20archivos/02.08%20Colisiones%20entre%20nombres%20y%20una%20introducci%C3%B3n%20a%20los%20espacios%20de%20nombres.md)**