# 02.03 Introducción a los parámetros y argumentos de las funciones

<details>
    <summary>Información del archivo</summary>

| Autor en inglés | Traductor al español | Fecha de creación | Última modificación |
| --------------- | -------------------- | ----------------- | ------------------- |
| Alex            | José De Freitas      | 25/01/2015        | 24/02/2021          |

</details>

En la lección anterior aprendimos que podemos hacer que una función retorne un valor a la
función que la llamó. Creamos una función llamada *getValueFromUser*, la cual usamos de esta
manera:
```cpp
#include <iostream>
 
int getValueFromUser()
{
 	std::cout << "Escribe un entero: ";
	int input{};
	std::cin >> input;  
 
	return input;
}
 
int main()
{
	int num { getValueFromUser() };
 
	std::cout << num << " multiplicado por 2 es: " << num * 2 << '\n';
 
	return 0;
}
```

Pero, ¿y si quisiéramos poner el output dentro de su propia función también? Es posible que
hayas pensado en hacer esto:
```cpp
#include <iostream>
 
int getValueFromUser()
{
 	std::cout << "Escribe un entero: ";
	int input{};
	std::cin >> input;  
 
	return input;
}
 
// Esta función no compilará
void printDouble()
{
	std::cout << num << " multiplicado por 2 es: " << num * 2 << '\n';
}
 
int main()
{
	int num { getValueFromUser() };
 
	printDouble();
 
	return 0;
}
```

Este programa no compilará porque la función *printDouble* no sabe qué es *num*. Es posible
que también intentes definir *num* como una variable dentro de la función *printDouble*:
```cpp
void printDouble()
{
	int num{}; // añadimos esta línea
	std::cout << num << " multiplicado por 2 es: " << num * 2 << '\n';
}
```

A pesar de que al agregar esa línea hacemos que el programa compile sin errores, el resultado
no será el que esperamos (siempre imprimirá "0 multiplicado por 2 es: 0"). El problema es que
la función *printDouble* no puede acceder al valor que introdujo el usuario.

Necesitamos alguna manera de pasar el valor de la variable *num* a la función *printDouble*
para que esta pueda usarlo.

#### **Índice**

1. [Parámetros y argumentos de las funciones](#parámetros-y-argumentos-de-las-funciones)
2. [Funcionamiento paralelo de los parámetros y argumentos](#funcionamiento-paralelo-de-los-parámetros-y-argumentos)
3. [Arreglando nuestro programa anterior](#arreglando-nuestro-programa-anterior)
4. [Usando valores de retorno como argumentos](#usando-valores-de-retorno-como-argumentos)
5. [Advertencia sobre el orden de evaluación de los argumentos de las funciones](#advertencia-sobre-el-orden-de-evaluación-de-los-argumentos-de-las-funciones)
6. [Funcionamiento paralelo de los parámetros y los valores de retorno](#reutilizando-funciones)
7. [Más ejemplos](#más-ejemplos)
8. [Conclusión](#conclusión)
9. [Prueba](#prueba)

## Parámetros y argumentos de las funciones

En muchos casos es muy útil pasar información *hacia* la función que estamos llamando para que
la función en cuestión tenga acceso a ciertos datos. Por ejemplo, si queremos escribir una
función que suma dos números necesitamos una manera de indicarle a la función cuáles números
se deben sumar. Si no le indicamos los números a la función, ¿cómo puede saber cuáles son los
números que tiene que sumar? Es por eso que hacemos uso de los parámetros y los argumentos.

Un **parámetro de función** es una variable usada en una función. Los parámetros de las
funciones funcionan casi igual que una variable definida dentro de una función, con la
diferencia de que estas siempre son inicializadas con un valor tomado de la llamada a la
función.

Los parámetros de las funciones se definen en la declaración de la función al ponerlos dentro
de los peréntesis que están luego del identificador de la función. Se usa una coma para
separar los parámetros.

Estos son unos ejemplos de funciones con diversos parámetros:
```cpp
// Esta función no toma ningún parámetro
// No depende de su llamada
void doPrint()
{
    std::cout << "En doPrint()\n";
}
 
// Esta función toma un parámetro de tipo entero llamado "x"
// La llamada a la función pasará el valor de "x"
void printValue(int x)
{
    std::cout << x  << '\n';
}
 
// Esta función tiene dos parámetros de tipo entero, uno llamado "x" y otro llamado "y"
// La llamada a la función pasará los valores de "x" y "y"
int add(int x, int y)
{
    return x + y;
}
```

Un **argumento** es un valor que es pasado *desde* la llamada a la función a la función:
```cpp
doPrint(); // esta llamada a la función no tiene argumentos
printValue(6); // 6 es el argumento pasado a la función printValue()
add(2, 3); // 2 y 3 son los argumentos pasados a la función add()
```

Los argumentos se separan con comas.

## Funcionamiento paralelo de los parámetros y argumentos

Cuando se llama a una función se crean todos los parámetros de la función, como las variables.
Los valores de cada argumento son *copiados* en el parámetro correspondiente. A este proceso
se le conoce como **pasado por valor**.

Por ejemplo:
```cpp
#include <iostream>
 
// Esta función tiene dos parámetros de tipo entero, uno llamado x y otro llamado y
// Los valores de x y y son pasados por la llamada a la función
void printValues(int x, int y)
{
    std::cout << x << '\n';
    std::cout << y << '\n';
}
 
int main()
{
    printValues(6, 7); // esta llamada a la función tiene dos argumentos, 6 y 7
 
    return 0;
}
```

Cuando se llama a la función *printValues* con los argumentso *6* y *7* se crea el parámetro
*x* y se inicializa con el valor *6*, al igual que el parámetro *y*, inicializado con el valor
*7*.

El resultado de este programa es:
```
6
7
```

Ten en cuenta que la cantidad de argumentos debe concordar con el número de parámetros de
la función; de lo contrario, el compilador devolverá un error. El argumento que es pasado a la
función puede ser cualquier expresión válida (ya que el argumento es tan solo un
inicializador del parámetro. Los inicializadores pueden ser cualquier expresión válida).

## Arreglando nuestro programa anterior

Ahora podemos arreglar el programa que escribimos al principio de la lección:
```cpp
#include <iostream>
 
int getValueFromUser()
{
 	std::cout << "Escribe un entero: ";
	int input{};
	std::cin >> input;  
 
	return input;
}
 
void printDouble(int value) // ahora esta función tiene un parámetro de tipo entero
{
	std::cout << value << " multiplicado por 2 es: " << value * 2 << '\n';
}
 
int main()
{
	int num { getValueFromUser() };
 
	printDouble(num);
 
	return 0;
}
```

La variable *num* se inicializa con el valor introducido por el usuario; luego se llama a la
función *printDouble* y se copia el valor *num* del argumento en el parámetro *value* de la
función *printDouble*. La función *printDouble* usa el valor del parámetro *value*.

## Usando valores de retorno como argumentos

En el programa anterior vemos que la variable *num* se usa una sola veces para transportar
el valor de retorno de la función *getValueFromUser* al argumento de la llamada a la función
*printDouble*.

Podemos simplificar el código de arriba de esta manera:
```cpp
#include <iostream>
 
int getValueFromUser()
{
 	std::cout << "Escribe un entero: ";
	int input{};
	std::cin >> input;  
 
	return input;
}
 
void printDouble(int value)
{
	std::cout << value << " multiplicado por 2 es: " << value * 2 << '\n';
}
 
int main()
{
	printDouble(getValueFromUser());
 
	return 0;
}
```

Ahora estamos usando el valor de retorno de la función *getValueFromUser* directamente como
un argumento de la función *printDouble*.

A pesar de que este programa es más conciso (y se asegura de aclarar que el valor introducido
por el usuario será usado para una sola cosa), puede que lo encuentres un poco difícil de leer
por la "sintaxis compacta" que tiene. Si te sientes más seguro usando la versión que usa la
variable, puedes usar esa en vez de esta.

## Advertencia sobre el orden de evaluación de los argumentos de las funciones

La especificación de C++ no define si los argumentos coinciden con los parámetros de
izquierda a derecha o de derecha a izquierda. Ya que se están copiando los valores, el orden
no tiene importancia. No obstante, si los argumentos son llamadas a funciones, esto puede
acarrear algunos problemas:
```cpp
someFunction(a(), b()); // a() o b() pueden ser llamados primero
```

Si el programa se evalúa de izquierda a derecha, a() será llamada antes que b(). Si el
programa se evalúa de derecha a izquierda, b() será llamada antes que a(). Esto puede o no
ser de importancia; depende de lo que hacen a() o b().

Si tu programa debe evaluar un argumento primero tienes que definir de manera explícita el
orden de la ejecución. Si es ese el caso, haz esto:
```cpp
int avar{ a() }; // a() siempre será llamada primero
int bvar{ b() }; // b() siempre será llamada después de a()
 
someFunction(avar, bvar); // no importa si avar o bvar se copian primero porque solo son valores
```

> **Advertencias**
>
> La especificación de C++ no define si las llamadas a las funciones evalúan los argumentos
> de izquierda a derecha o de derecha a izquierda. Asegúrate de no hacer llamadas a funciones
> cuando importa el orden de los argumentos.

## Funcionamiento paralelo de los parámetros y los valores de retorno

Si usamos tanto parámetros como valores de retorno podemos crear funciones que toman datos
como input, hacen cálculos con ellos y retornan el valor a la función que llamó a la función.

Aquí está un ejemplo de una función simple que añade dos números y retorna el resultado:
```cpp
#include <iostream>
 
// add() toma dos enteros como parámetros y retorna el resultado de su suma
// Los valores x y y se determinan por la función que llama a add()
int add(int x, int y)
{
    return x + y;
}
 
// main no toma ningún parámetro
int main()
{
    std::cout << add(4, 5) << '\n'; // los argumentos 4 y 5 son pasados a la función add()
    return 0;
}
```

La ejecución del programa empieza en la función *main*. Cuando se evalúa `add(4, 5)` se llama
a la función *add* con el parámetro *x* inicializado con el valor *4* y el parámetro *y*
inicializado con el valor *5*.

La *declaración de retorno* en la función *add* evalúa *x + y* para producir el valor *9*, el
cual es retornado a la función *main*. El valor *9* se envía a *std::cout*, imprimiéndose
luego en la consola.

Output:
```
9
```

En formato pictórico:

**INSERTE IMAGEN**

## Más ejemplos

Veamos estas llamadas a funciones:
```cpp
#include <iostream>
 
int add(int x, int y)
{
    return x + y;
}
 
int multiply(int z, int w)
{
    return z * w;
}
 
int main()
{
    std::cout << add(4, 5) << '\n'; // entre add() x=4, y=5, entonces x+y=9
    std::cout << add(1 + 2, 3 * 4) << '\n'; // entre add() x=3, y=12, entonces x+y=15
 
    int a{ 5 };
    std::cout << add(a, a) << '\n'; // evalúa (5 + 5)
 
    std::cout << add(1, multiply(2, 3)) << '\n'; // evalúa 1 + (2 * 3)
    std::cout << add(1, add(2, 3)) << '\n'; // evalúa 1 + (2 + 3)
 
    return 0;
}
```

El output de este programa es:
```
9
15
10
7
6
```

La primera declaración está bien.

En la segunda declaración los argumentos son expresiones que se evalúan antes de ser pasadas.
En este caso *1 + 2* evalúa a *3*, por lo que *3* se copia al parámetro *x*. *3 * 4* se
evalúa a *12*, por lo que *12* se copía al parámetro *y*. *add(3, 12)* devuelve *15*.

El siguiente par de declaraciones es relativamente fácil de entender:
```cpp
    int a{ 5 };
    std::cout << add(a, a) << '\n'; // evalúa (5 + 5)
```

En este caso, *add()* se llama mientras se copia el valor de *a* en ambos parámetros, *x* y
*y*. Como *a* tiene el valor *5*, *add(a, a) = add(5, 5)*, devolviendo el valor *10*.

Veamos la primera declaración que es complicada:
```cpp
    std::cout << add(1, multiply(2, 3)) << '\n'; // evaluates 1 + (2 * 3)
```

Cuando se ejecuta la función *add* el programa necesita determinar cuáles son los valores
de los parámetros *x* y *y*. Ya sabemos cuál es el de *x* ya que pasamos el entero *1*. Para
obtener un valor para el parámetro *y* necesitamos evaluar *multiply(2, 3)* primero. El
programa llama a la función *multiply* e inicializa *z* a *2* y *w* a *3*, por lo que
*multiply(2, 3)* retorna el valor entero *6*. Ese valor de retorno puede ser usado para
inicializar el parámetro *y* de la función *add*. *add(1, 6)* retorna el entero *7*, el cual
es pasado a *std::cout* para ser imprimido en la consola.

Resumen de la explicación anterior: *add(1, multiply(2, 3))* evalúa a *add(1, 6)*, que evalúa
a su vez a *7*.

La siguiente declaración parece complicada porque uno de los argumentos pasados a *add* es
otra llamada a *add*:
```cpp
    std::cout << add(1, add(2, 3)) << '\n'; // evalúa 1 + (2 + 3)
```

Pero este caso es igual que el caso anterior. *add(2, 3)* se evalúa primero, resultando en
el valor de retorno *5*. Ahora se puede evaluar *add(1, 5)*, dando como resultado el entero
*6*, que es luego pasado a *std::cout* para ser imprimido en la consola.

Resumen de la explicación anterior: *add(1, add(2, 3))* evalúa a *add(1, 5)*, que evalúa a su
vez a *6*.

## Conclusión

Los parámetros de las funciones y los valores de retorno son los mecanismos claves que
hacen que las funciones puedan ser reutilizadas de manera dinámica ya que nos permiten
escribir funciones que hacen ciertas tareas y retornan los valores calculados a la función
que llamó a la función en cuestión sin la necesidad de conocer el input o el output.

## Prueba

**Pregunta 1**

¿Cuál es el error en la siguiente porción de código?

```cpp
#include <iostream>
 
void multiply(int x, int y)
{
    return x * y;
}
 
int main()
{
    std::cout << multiply(4, 5) << '\n';
    return 0;
}
```

<details>
    <summary>Mostrar solución</summary>
    multiply() es definida con un tipo de valor de retorno void, que quiere decir que no retorna ningún valor. Ya que la función, en este caso, sí está devolviendo un valor, esta función producirá un error de compilación. La función debe tener un tipo de valor de retorno int.
</details>

**Pregunta 2**

¿Cuáles son lso 2 errores en la siguiente porción de código?

```cpp
#include <iostream>
 
int multiply(int x, int y)
{
    int product{ x * y };
}
 
int main()
{
    std::cout << multiply(4) << '\n';
    return 0;
}
```

<details>
    <summary>Mostrar solución</summary>
    Problema 1: main() pasa un argumento a multiply() pero multiply() requiere dos parámetros.
	Problema 2: multiply() carece de una declaración de retorno.
</details>

**Pregunta 3**

¿Qué valor imprime el siguiente programa?

```cpp
#include <iostream>
 
int add(int x, int y, int z)
{
    return x + y + z;
}
 
int multiply(int x, int y)
{
    return x * y;
}
 
int main()
{
    std::cout << multiply(add(1, 2, 3), 4) << '\n';
    return 0;
}
```

<details>
    <summary>Mostrar solución</summary>
    Se llama a multiply, la cual hace x = add(1, 2, 3) y y = 4. Primero el CPU evalúa x = add(1, 2, 3), que retorna 1 + 2 + 3 o x = 6. multiply(6, 4) = 24 es el valor resultante.
</details>

**Pregunta 4**

Escribe una función llamada *doubleNumber()* que toma un parámetro de tipo entero. La función
debe retornar el valor del parámetro multiplicado por 2.

<details>
    <summary>Mostrar solución</summary>

	int doubleNumber(int x)
	{
    	return 2 * x;
	}

</details>

**Pregunta 5**

Escribe un programa completo que tome un entero del usuario, lo multiplique por 2 usando la
función *doubleNumber()* que escribiste en la pregunta anterior y que imprima el valor
multiplicado por 2 en la consola.

<details>
    <summary>Mostrar solución</summary>

	#include <iostream>
 
	int doubleNumber(int x)
	{
    	return 2 * x;
	}
 
	int main()
	{
    	int x{};
    	std::cin >> x;
    	std::cout << doubleNumber(x) << '\n';
    	return 0;
	}

Nota: puede que hayas escrito este programa de forma diferente. En C++ hay muchas formas de
hacer una misma cosa.
</details>

---

**[Lección anterior](/Contenido/Cap%C3%ADtulo%2002%20Fundamentos%20de%20C%2B%2B%20-%20Funciones%20y%20archivos/02.02%20Valores%20de%20retorno%20de%20las%20funciones.md)** - **[Contenido](https://github.com/JoseDeFreitas/learncpp.es#contenido)** - **[Lección siguiente](/Contenido/Cap%C3%ADtulo%2002%20Fundamentos%20de%20C%2B%2B%20-%20Funciones%20y%20archivos/02.04%20Introducci%C3%B3n%20al%20alcance%20local.md)**