# 02.04 Introducción al alcance local

<details>
    <summary>Información del archivo</summary>

| Autor en inglés | Traductor al español | Fecha de creación | Última modificación |
| --------------- | -------------------- | ----------------- | ------------------- |
| Alex            | José De Freitas      | 08/02/2015        | 05/05/2020          |

</details>

#### **Índice**

1. [Variables locales](#variables-locales)
2. [La vida de las variables locales](#la-vida-de-las-variables-locales)
3. [Alcance local](#alcance-local)
4. [Otro ejemplo](#otro-ejemplo)
5. [Separación funcional](#separación-funcional)
6. [Dónde definir variables locales](#dónde-definir-variables-locales)
7. [Prueba](#prueba)

## Variables locales

Los parámetros de las funciones, así como las variables definidas dentro del cuerpo de una
función, son llamadas **variables locales** (en contraste con las variables globales, de las
que hablaremos en un próximo capítulo).

```cpp
int add(int x, int y) // los parámetros "x" y "y" son variables locales
{
    int z{ x + y }; // "z" también es una variable local
 
    return z;
}
```

En esta lección veremos las propiedades de las variables locales.

## La vida de las variables locales

En la [lección 01.03](/Contenido/Cap%C3%ADtulo%2001%20Fundamentos%20de%20C%2B%2B/01.03%20Introducci%C3%B3n%20a%20las%20variables.md)
discutimos cómo una definición de una variable (como `int x;`) hace que la variable se
inicialice (se cree) cuando se ejecuta la declaración. Los parámetros de las funciones son
creados e inicializados cuando el programa entra a la función y las variables dentro de las
funciones son creadas e inicializadas cuando son definidas.

Por ejemplo:
```cpp
int add(int x, int y) // "x" y "y" son creadas e inicializadas aquí
{ 
    int z{ x + y }; // "z" se crea y se inicializa aquí
 
    return z;
}
```

Una pregunta común luego de ver esto es "¿cuándo, entonces, se destruye una variable
inicializada?". Las variables locales son destruidas en el orden opuesto de la creación al
final de las llaves donde es definida (o para un parámetro de función al final de esta).

```cpp
int add(int x, int y)
{ 
    int z{ x + y };
 
    return z;
} // "z", "y" y "x" se destruyen aquí
```

Al igual que el tiempo de vida de una persona dura desde el nacimiento hasta la muerte, el
**tiempo de vida** de un objeto se define desde su creación y su destrucción. La creación y
destrucción de una variable ocurren cuando el programa está en ejecución, no cuando se compila
el programa. Es por eso que el tiempo de vida es una propiedad de la ejecución.

> **Para lectores avanzados**
>
> Las reglas de arriba sobre la creación, inicialización y destrucción de variables son
> garantías. Esto quiere decir que los objetos deben ser creados e inicializados antes de
> la definición y destruidos después del final de las llaves en donde están definidas (o,
> refiriéndonos a los parámetros de las funciones, al final de la función).
>
> En la práctica la especificación de C++ le da mucha flexibilidad a los compiladores de
> determinar cuándo se crean y se destruyen las variables locales. Puede que los objetos se
> creean antes o se destruyan después por motivos de optimización. En la mayoría del tiempo
> las varaibles locales son creadas cuando el programa entra en al función y destruidas cuando
> se va de la función. Discutiremos sobre esto con más detalle en una próxima declaración, en
> la que también hablaremos sobre la pila de llamadas.

Aquí está un programa un poco más complejo que demuestra el tiempo de vida de una variable
llamada *x*:
```cpp
#include <iostream>
 
void doSomething()
{
    std::cout << "¡Hola!\n";
}
 
int main()
{
    int x{ 0 }; // aquí comienza el tiempo de vida de "x"
 
    doSomething(); // "x" está en su tiempo de vida durante esta llamada de función
 
    return 0;
} // aquí concluye el tiempo de vida de "x"
```

En el programa de arriba el tiempo de vida de *x* dura desde el comienzo hasta el final de la
función *main*. Esto incluye el tiempo que dura la ejecución de la función *doSomething*.

## Alcance local

El **alcance** de un identificador determina desde dónde se puede acceder al identificador
en el código fuente. Cuando se puede acceder a un identificador decimos que está
**al alcance**. Cuando no podemos acceder a un identificador decimos que está
**fuera de alcance**. El alcace es una propiedad de la compilación; si intentamos usar un
identificador cuando está fuera de alcance obtendremos un error de compilación.

El alcance de una variable local empieza en la definición de la variable y termina al final
de las llaves en donde está definida (para los parámetros de funciones, termina al final de
la función). De esta manera el programa se asegura de que las variables no se usen antes de
su definición (incluso si el compilador decide crearlas antes).

Aquí está un programa que demuestra el alcance de una variable llamada *x*.
```cpp
#include <iostream>
 
// "x" está fuera de alcance en esta función
void doSomething()
{
    std::cout << "¡Hola!\n";
}
 
int main()
{
    // "x" no se puede usar aquí porque todavía no está al alcance.
 
    int x{ 0 }; // "x" entra al alcance y puede ser usada aquí
 
    doSomething();
 
    return 0;
} // "x" está ahora fuera de alcance y ya no puede ser usada
```

En el programa de arriba la variable *x* entra al alcance cuando se define y sale del alcance
cuando se termina la función *main*. Ten en cuenta que la variable *x* está fuera de alcance
en cualquier lugar de la función *doSomething*. El hecho de que la función *main* llama a la
función *doSomething* es irrelevante en este contexto.

Las variables locales tienen las mismas definiciones para el alcance y el tiempo de vida. Para
las variables locales, el alcance y el tiempo de vida están vinculados; eso quiere decir que
el tiempo de vida de una variable comienza cuando entra al alcance y termina cuando se va del
alcance.

## Otro ejemplo

Este es un ejemplo más complejo. Recuerda que el tiempo de vida es una propiedad de la
ejecución y el alcance es una propiedad de la compilación. A pesar de que estamos hablando
de ambos en el mismo programa, están reforzados en puntos diferentes.

```cpp
#include <iostream>
 
int add(int x, int y) // "x" y "y" son creadas y entran al alcance aquí
{
    // "x" y "y" son visibles y se pueden usar solo dentro de esta función
    return x + y;
} // "y" y "x" ya no están al alcance y se destruyen aquí
 
int main()
{
    int a{ 5 }; // se crea "a", se incicializa y entra al alcance
    int b{ 6 }; // se crea "b", se incicializa y entra al alcance
 
    // "a" y "b" se pueden usar solo dentro de esta función
    std::cout << add(a, b) << '\n'; // llama a la función add() con x=5 y y=6
 
    return 0;
} // "b" y "a" ya no están al alcance y se destruyen aquí
```

Los parámetros *x* y *y* son creados cuando se llama a la función *add*, pueden ser
vistos/usados solo dentro de la función *add* y son destruidos luego al final de la función
*add*. Las variables *a* y *b* se crean dentro de la función *main*, pueden ser vistos/usados
solo dentro de la función *main* y son destruidos al final de la función *main*.

Para aclarar un poco mejor estos conceptos veamos este programa con más detalle. Lo que
ocurre en el programa es lo siguiente (en este orden):
- Comienza la ejecución al principio de *main*.
- Se crea la variable *a* dentro de *main* con el valor de 5.
- Se crea la variable *b* dentro de *main* con el valor de 6.
- Se llama a la función *add* con los valores *5* y *6* como argumentos.
- Se crea e inicializa la variable *x* dentro de *add* con el valor de 5.
- Se crea e inicializa la variable *y* dentro de *add* con el valor de 6.
- El operador + evalúa la expresión *x + y* para producir el valor *11*.
- *add* copie el valor *11* a la función *main*.
- Se destruyen las variables *y* y *x* de la *add*.
- *main* imprime *11* en la consola.
- *main* retorna *0* al sistema operativo.
- Se destruyen las variables *b* y *a* de *main*.

Y listo.

Es importante notar que si se llamara dos veces a la función *add*, los parámetros *x* y *y*
serían creados y destruidos dos veces, una vez por cada llamada. En un programa con muchas
funciones y llamadas a funciones se crean y se destruyen variables muy comúnmente.

## Separación funcional

En el ejemplo anterior es fácil notar que las variables *a* y *b* son diferentes de las
variables *x* y *y*.

Mira ahora este programa parecido al anterior:
```cpp
#include <iostream>
 
int add(int x, int y) // "x" y "y" de "add" son creadas y entran al alcance aquí
{
    // "x" y "y" de "add" son visibles y se pueden usar solo dentro de esta función
    return x + y;
} // "y" y "x" de "add" ya no están al alcance y se destruyen aquí
 
int main()
{
    int x{ 5 }; // se crea "x" en "main", se incicializa y entra al alcance
    int y{ 6 }; // se crea "y" en "main", se incicializa y entra al alcance
 
    // "x" y "y" de "main" se pueden usar solo dentro de esta función
    std::cout << add(x, y) << '\n'; // llama a la función add() con x=5 y y=6
 
    return 0;
} // "y" y "x" de "main" ya no están al alcance y se destruyen aquí
```

En este ejemplo lo único que hicimos fue cambiar el nombre de las variables *a* y *b* dentro
de la función *main* a *x* y *y*. Este programa compila y se ejecuta de manera idéntica a
pesar de que ambas funciones (*main* y *add*) tienen variables llamadas *x* y *y*. ¿Cómo y
por qué funciona esto?

Primero: vemos que a pesar de que tanto como la función *main* y *add* tienen variables
llamadas *x* y *y*, estas variables son distintas. Las variables *x* y *y* en la función
*main* no tienen nada que ver con las variables *x* y *y* en la función *add*, simplemente
comparten los mismos nombres.

Segundo: cuando el programa está dentro de la función *main*, los nombres *x* y *y* hacen
referencia a las variables locales de *main* *x* y *y*. Esas variables solo pueden ser vistas
(y usadas) dentro de *main*. De igual manera cuando el programa está dentro de la función
*add*, los nombres *x* y *y* hacen referencia a los parámetros de función *x* y *y*, los
cuales solo pueden ser vistos (y usados) dentro de *add*.

En resumen, ni *add* ni *main* saben que la otra función tiene variables con los mismos
nombres. Ya que las variables no se sobrescriben entre ellas el compilador sabe a cuáles
*x* y *y* se está haciendo referencia en cualquier momento.

> **Información clave**
>
> Los nombres usados para los parámetros de las funciones o para las variables declaradas en
> el cuerpo de una función son solo visibles dentro de la función que las declara. Esto
> significa que las variables locales dentro de una función pueden ser nombradas sin importar
> los nombres de variables de otroas funciones. Esto ayuda a que las funciones sean
> independientes.

Hablaremos más sobre el alcance local y otros tipos de alcance en un próximo capítulo.

## Dónde definir variables locales

Las variables locales dentro del cuerpo de la función deben ser definidas lo más cerca de
su primer uso razonable:
```cpp
#include <iostream>
 
int main()
{
	std::cout << "Escribe un entero: ";
	int x{}; // "x" se define aquí
	std::cin >> x; // y se usa aquí
 
	std::cout << "Escribe otro entero: ";
	int y{}; // "y" se define aquí
	std::cin >> y; // y se usa aquí
 
	int sum{ x + y }; // "sum" se define aquí
	std::cout << "La suma es: " << sum << '\n'; // y se usa aquí
 
	return 0;
}
```

En este ejemplo vemos que cada variable es definida justo antes de su primer uso. No hay
necesidad de ser estricto con esto; si quieres cambiar las líneas 5 y 6, está bien.

> **Mejores prácticas**
>
> Define tus variables locales lo más cerca de su primer uso razonable.

## Prueba

**Pregunta 1**

¿Qué imprime el siguiente programa?

```cpp
#include <iostream>
 
void doIt(int x)
{
    int y{ 4 };
    std::cout << "doIt: x = " << x << " y = " << y << '\n';
 
    x = 3;
    std::cout << "doIt: x = " << x << " y = " << y << '\n';
}
 
int main()
{
    int x{ 1 };
    int y{ 2 };
 
    std::cout << "main: x = " << x << " y = " << y << '\n';
 
    doIt(x);
 
    std::cout << "main: x = " << x << " y = " << y << '\n';
 
    return 0;
}
```

<details>
    <summary>Mostrar solución</summary>
    
    main: x = 1 y = 2
    doIt: x = 1 y = 4
    doIt: x = 3 y = 4
    main: x = 1 y = 2

Esto es lo que ocurre en este programa:
- La ejecución empieza al principio de *main*.
- Se crea la variable *x* dentro de *main* con el valor de *1*.
- Se crea la variable *y* dentro de *main* con el valor de *2*.
- *std::cout* imprime *main: x = 1 y = 2*.
- *doIt* es llamada con el argumento *1*.
- Se crea el parámetro *x* dentro de *doIt* con el valor de *1*.
- Se crea la variable *y* dentro de *doIt* con el valor de *4*.
- *doIt* imprime *doIt: x = 1 y = 4*.
- Se asigna el valor *3* a la variable *x* dentro de *doIt*.
- *std::cout* imprime *doIt: x = 3 y = 4*.
- Se destruyen *y* y *x* de *doIt*.
- *std::cout* imprime *main: x = 1 y = 2*.
- *main* retorna *0* al sistema operativo.
- Se destruyen *y* y *x* de *main*.

Ten en cuenta que a pesar de que las variables *x* y *y* de *doIt* tienen sus valores
inicializados o asignados a algo diferente que los valores de *main*, las variables *x* y *y*
de *main* no son afectadas porque son variables diferentes.
</details>

---

**[Lección anterior](/Contenido/Cap%C3%ADtulo%2002%20Fundamentos%20de%20C%2B%2B%20-%20Funciones%20y%20archivos/02.03%20Introducci%C3%B3n%20a%20los%20par%C3%A1metros%20y%20argumentos%20de%20las%20funciones.md)** - **[Contenido](https://github.com/JoseDeFreitas/learncpp.es#contenido)** - **[Lección siguiente](https://github.com/JoseDeFreitas/learncpp.es/blob/main/Contenido/Cap%C3%ADtulo%2002%20Fundamentos%20de%20C%2B%2B%20-%20Funciones%20y%20archivos/02.05%20El%20porqu%C3%A9%20las%20funciones%20son%20%C3%BAtiles%20y%20c%C3%B3mo%20usarlas%20efectivamente.md)**