# 01.11 Desarrollando tu primer programa

<details>
    <summary>Información del archivo</summary>

| Autor en inglés | Traductor al español | Fecha de creación | Última modificación |
| --------------- | -------------------- | ----------------- | ------------------- |
| Alex            | José De Freitas      | 01/02/2019        | 26/12/2020          |

</details>

En las lecciones pasadas te enseñamos un montón de términos y conceptos que usaremos en
todos los programas que creemos. En esta lección te explicaremos cómo juntar este conocimiento
para hacer nuestro primer programa.

#### **Índice**

1. [Multiplicación por 2](#multiplicación-por-2)
2. [La solución mala](#la-solución-mala)
3. [La solución buena](#la-solución-buena)
4. [La solución recomendada](#la-solución-recomendada)
5. [Prueba](#prueba)

## Multiplicación por 2

Primero creemos un programa que le permita al usuario escribir un número entero, espere a que
el usuario escriba ese número y luego devuelva ese número multiplicado por 2. El programa
debería producir el siguiente output (asumiendo que escribimos 4 como input):
```
Escribe un entero: 4
El entero multiplicado por 2 es: 8
```

¿Cómo hacermos un programa así? Veámoslo paso a paso.

> **Mejores prácticas**
>
> Los programadores novatos suelen escribir un programa entero de una vez y luego se sienten
> agobiados debido a los errores que devuelve el programa. Es mejor escribir el código por
> porciones e ir compilándolo a medida que lo escribes para probarlo. Si todo funciona bien
> puedes escribir la siguiente porción.

Aprovecharemos esa estrategia. Mientras vayamos paso a paso con nuestro programa, escribe
(no copies y pegues) cada porción en tu editor de texto, compila el programa y ejecútalo.

Primero creemos un nuevo proyecto de consola.

Ahora escribiremos las bases del proyecto. Ya sabemos que necesitaremos una función main
(necesaria en C++); si tu IDE no creó una cuando creaste el proyecto, puedes escribirla tu
mismo:
```cpp
int main()
{
    return 0;
}
```

Sabemos que necesitaremos enviar output a la consola y recibir input del usuario, por lo que
incluiremos la librería iostream para tener acceso a std::cout y std::cin:
```cpp
#include <iostream>

int main()
{
    return 0;
}
```

Ahora pidámosle al usuario que escribe un entero:
```cpp
#include <iostream>

int main()
{
    std::cout << "Escribe un entero: ";

    return 0;
}
```

En este punto tu programa debería producir el siguiente resultado:
```
Escribe un entero: 
```
para luego terminar su ejecución.

Despúes recibiremos el input del usuario. Usaremos std::cin y el operador >>. También
necesitamos definir una variable que almacene el input del usuario y así poder usarlo luego:
```cpp
#include <iostream>

int main()
{
    std::cout << "Escribe un entero: ";

    int num{ 0 }; // define una variable llamada "num" de tipo int
    std::cin << num; // recibe el valor del input del usuario

    return 0;
}
```

Hora de compilar nuestros cambios...

Pero... ¡Oh! Parece que hay un error. Esto obtuvo el autor en Visual Studio 2017:
```
1>------ Build started: Project: Double, Configuration: Release Win32 ------
1>Double.cpp
1>c:\vcprojects\double\double.cpp(8): error C2678: binary '<<': no operator found which takes a left-hand operand of type 'std::istream' (or there is no acceptable conversion)
1>c:\vcprojects\double\double.cpp: note: could be 'built-in C++ operator<<(bool, int)'
1>c:\vcprojects\double\double.cpp: note: while trying to match the argument list '(std::istream, int)'
1>Done building project "Double.vcxproj" -- FAILED.
========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========
```

¡Es un error de compilación!

Primero: ya que el programa compiló antes de que hicimos el último cambio y no compila ahora,
el error *debe* estar en las líneas de código que acabamos de añadir (líneas 7 y 8). Eso
reduce de manera significante la cantidad de código que tenemos que leer para descubrir el
error. La línea 7 parece bien (solo estamos definiendo una variable), por lo que el error no
está ahí. Eso nos deja con la línea culpable: la línea 8.

Segundo: este mensaje de error no es muy fácil de entender. Aún así, vamos a separarlo en
partes para anotar los elementos importantes: el compilador nos dice que hay un error en la
línea 8. Eso significa que la línea 8 es probablemente la del error, pero también puede estar
en una línea posterior, lo cual reafirma nuestra declaración previa. Luego el compilador nos
dice que no pudo encontrar un operador "<<" que tenga un operando al lado izquierdo de tipo
std::istream (el tipo de std::cin). Dicho de otra manera, el operador << no sabe qué hacer con
std::cin; por esto, el mensaje de error se refiere al uso de std::cin o al uso del operador
<<.

¿Ves ahora el error? Si no, tómate un momento para verlo.

Aquí está el mismo programa pero sin el error:
```cpp
#include <iostream>

int main()
{
    std::cout << "Escribe un entero: ";

    int num{ 0 };
    std::cin >> num; // std::cin usa el operador >>, no el operador <<

    return 0;
}
```

Ahora el programa compilará y podremos probarlo. El programa esperará a que escribas un
número. Vamos a escribir el 4. El output debe ser el siguiente:
```
Escribe un entero: 4
```

¡Ya estamos casi listos! El último paso consiste en duplicar ese número.

Cuando terminemos con el último paso veremos que nuestro programa compila y se ejecuta
satisfactoriamente, devolviendo el output que esperábamos.

Hay (al menos) 3 maneras de hacer este último paso. Vayamos desde la peor hasta la mejor.

## La solución mala

```cpp
#include <iostream>

// solución mala
int main()
{
    std::cout << "Escribe un entero: ";

    int num{ 0 };
    std::cin >> num;

    num = num * 2; // duplicamos en valor de num y luego asignamos ese valor de vuelta en num

    std::cout << "El entero multiplicado por 2 es: " << num << '\n';

    return 0;
}
```

En esta solución estamos usando una expresión para multiplicar *num* por 2 y luego le
asignamos a *num* el valor multiplicado. Desde ese punto, la variable *num* almacenará
el número multiplicado por 2.

¿Por qué es esta una mala solución?
- Antes de la declaración de asignación, *num* almacena el input del usuario. Luego de la
asignación, *num* almacena un valor diferente. Eso es un poco confuso.
- Sobrescribimos el valor que introdujo el usuario al asignarle un nuevo valor a la variable.
Es por esto que, si quisiéramos extender nuestro programa para que haga otra cosa con el
valor que introdujo el usuario (por ejemplo, multiplicarlo por 3), ya no podremos usarlo
ya que se perdió al sobrescribirlo.

## La solución buena

```cpp
#include <iostream>

// solución menos mala
int main()
{
    std::cout << "Escribe un entero: ";

    int num{ 0 };
    std::cin >> num;

    int doublenum{ num * 2 }; // definimos una nueva variable y la inicializamos con el número por 2
    std::cout << "El entero multiplicado por 2 es: " << doublenum << '\n'; // luego imprimimos en la consola el valor de variable

    return 0;
}
```

Esta solución es fácil de entender y funciona bien, además de que resuelve los problemas que
tuvimos en la solución anterior.

Sin embargo, la primera desventaja de esta solución es que estamos definiendo una nueva
variable (lo cual añade complejidad a nuestro programa) para almacenar un valor que usaremos
una sola vez. Sé que podemos hacerlo mejor.

## La solución recomendada

```cpp
#include <iostream>

// solución recomendada
int main()
{
    std::cout << "Escribe un entero: ";

    int num{ 0 };
    std::cin >> num;

    std::cout << "El entero multiplicado por 2 es: " << num * 2 << '\n'; // usamos una expresión para multiplicar el número por 2 a la vez que lo imprimimos en la consola

    return 0;
}
```

Esta es la solución recomendada en comparación al resto. Cuando se ejecuta std::cout se
evaluará la expresión *num * 2* y veremos el resultado: *num* multiplicado por 2. Ese valor
se imprimirá en la consola. El valor *num* quedará intacto, por lo que podremos usarlo luego
si queremos.

Esta solución recomendada es nuestra referencia.

> **Nota del autor**
>
> El primer objetivo de la programación es hacer que tu programa funcione. Un programa que
> no funciona no es útil, sin importar cómo esté escrito.
>
> No obstante, hay un dicho que me gusta mucho: "Tienes que escribir un programa cuando sepas
> cómo deberías haberlo escrito en un principio". Esto quiere decir que la mejor solución
> no es necesariamente la más obvia, y que las primeras soluciones que escribamos no suelen
> ser tan buenas como deberían.
>
> Cuando estamos enfocados en entender cómo funciona un programa no tiene mucho sentido
> invertir un montón de tiempo en escribir código que ni siquiera sabemos si vamos a dejar.
> Por eso tomamos atajos. Nos saltamos cosas como la gestión de errores y los comentarios.
> Esparcimos código en nuestra solución para ayudarnos a determinar cuáles son los errores.
> Aprendemos a medida de que vamos programando; las cosas que pensábamos que funcionaban no
> funcionan y tenemos que encontrar otra solución.
>
> La conclusión es que las soluciones que escribirmos al principio no suelen estar bien
> estructuradas, robustas, legibles o concisas. Ten en cuenta que tu programa no está listo
> cuando hayas terminado de escribirmos (a menos que el programa sea muy pequeño y sencillo).
> El paso siguiente es limpiar el código. Esta práctica consta de: eliminar (o comentar)
> código de depuración, añadir comentarios, gestionar los errores, formatear tu código y
> asegurarte de que sigues las mejores prácticas. Y aún así puede que tu programa no sea tan
> simple como puede ser; quizás hay lógica redundante que puede ser consolidada o varias
> declaraciones que pueden ser combinadas en una, así como variables que no se necesitan o
> miles de pequeñas cosas más que pueden ser simplificadas. Los programadores novatos suelen
> enfocarse en optimizar el rendimiento cuando deberían enfocarse en optimizar el
> mantenimiento.
>
> Pocas soluciones que presentamos en estos tutoriales fueron escritas una sola vez. La
> mayoría es el resultado de mejoras constantes hasta que no pudo encontrarse alguna otra
> cosa que mejorar. ¡Tu puedes encontrar algo que mejorar!
>
> Conclusión de todo esto: no te frustres si tus soluciones no están perfectamente optimizadas
> a la primera. Es completamente normal. La perfección en la programación es un proceso
> repetitivo (un proceso que requiere de muchos pasos).

> **Nota del autor**
>
> Una cosa más: debes estar pensando: "C++ tiene muchas reglas y conceptos. ¿Cómo voy a
> recordar todo esto?
>
> Respuesta corta: no intentes recordarlo. C++ consiste en usar lo que ya conoces y buscar
> cómo hacer todo lo demás.
>
> Si estás leyendo esto por primera vez, concéntrate menos en memorizar reglas o conceptos
> específicos; es mejor que te concentres en entender qué es posible. Luego, cuando necesites
> implementar algo en un programa que estás desarrollando, puedes volver aquí (o a un
> sitio de referencia) y refrescar tu conocimientos sobre lo que quieras.

## Prueba

**Pregunta 1**

Modifica la "solución recomendada" de arriba para que el resultado sea el siguiente
(asumuendo que el input del usuario es 4):
```
Escribe un entero: 4
Entero 4 multiplicado por 2: 8
Entero 4 multiplicado por 4: 12
```

<details>
    <summary>Mostrar solución</summary>

    ```cpp
    #include <iostream>

    int main()
    {
        std::cout << "Escribe un entero: ";

        int num{ 0 };
        std::cin >> num;

        std::cout << "Entero " << num << "multiplicado por 2: " << num * 2 << '\n';
        std::cout << "Entero " << num << "multiplicado por 3: " << num * 3 << '\n';

        return 0;
    }
    ```
</details>

---

**[Lección anterior](/Contenido/Cap%C3%ADtulo%2001%20Fundamentos%20de%20C%2B%2B/01.10%20Introducci%C3%B3n%20a%20las%20expresiones.md)** - **[Contenido](https://github.com/JoseDeFreitas/learncpp.es#contenido)** - **[Lección siguiente](/Contenido/Cap%C3%ADtulo%2001%20Fundamentos%20de%20C%2B%2B/01.XX%20Resumen%20del%20Cap%C3%ADtulo%2001%20y%20evaluaci%C3%B3n.md)**