# 02.02 Valores de retorno de las funciones

<details>
    <summary>Información del archivo</summary>

| Autor en inglés | Traductor al español | Fecha de creación | Última modificación |
| --------------- | -------------------- | ----------------- | ------------------- |
| Alex            | José De Freitas      | 01/02/2019        | 06/11/2020          |

</details>

Mira este programa:
```cpp
#include <iostream>

int main()
{
    // Recibir valor del usuario
    std::cout << "Escribe un entero: ";
    int num{};
    std::cin >> num;

    // Imprime el valor multiplicado por 2
    std::cout << num << " el número multiplicado por 2 es: " << num * 2 << '\n';

    return 0;
}
```

Este programa está compuesto de dos partes: la primera consiste en recibir un valor del
usuario. La segunda consiste en imprimir el valor que introdujo el usuario multiplicado por
2.

A pesar de que este programa es bastante sencillo que no tenemos que partirlo en diferentes
funciones, ¿y si queremos hacerlo? Obtener un valor entero del usuario es una acción que
queremos que haga nuestro programa, por lo que puede ser un buen candidato para meterla en
una función.

Miremos ahora este programa:
```cpp
// Este programa no funciona

#include <iostream>

void getValueFromUser()
{
    std::cout << "Escribe un entero: ";
    int input{};
    std::cin >> input;
}

int main()
{
    getValueFromUser(); // pedirle un valor al usuario

    int num{}; // ¿cómo obtenemos el valor de getValueFromUser() y lo usamos para inicializar esta variable?

    std::cout << num << " el número multiplicado por 2 es: " << num * 2 << '\n';

    return 0;
}
```

A pesar de que esta podría ser una buena solución, este programa no funciona.

Al llamar a la función *getValueFromUser* el programa le pide al usuario que escriba un número
entero. Sin embargo, este valor se pierde cuando la función *getValueFromUser* termina y
el programa regresa a la función *main*. La variable *num* nunca se inicializa con el valor
que introdujo el usuario, por lo que el programa siempre imprime 0.

Lo que nuestro programa necesita es que la función *getValueFromUser* devuelva el valor que
el usuario introdujo para poder ser utilizado en la función *main*.

#### **Índice**

1. [Valores de retorno](#valores-de-retorno)
2. [Reparando nuestro programa](#reparando-nuestro-programa)
3. [Valores de retorno void](#valores-de-retorno-void)
4. [Retornando de main](#retornando-de-main)
5. [Notas adicionales sobre los valores de retorno](#notas-adicionales-sobre-los-valores-de-retorno)
6. [Reutilizando funciones](#reutilizando-funciones)
7. [Conclusión](#conclusión)
8. [Prueba](#prueba)

## Valores de retorno

Cuando escribes una función definida por ti, tienes que determinar si tu functión retornará
un valor o no. Para retornar un valor se necesitan dos cosas.

La primera: tu función tiene que determinar qué tipo de valor retornará. Para hacer esto
debemos especificar el **tipo de retorno** de la función; la palabra que escribimos antes del
nombre de la función. En el ejemplo de arriba, la función *getValueFromUser* tiene un tipo
de retorno *void*, mientras que la función *main* tiene un tipo de retorno *int*. Ten en
cuenta que esto no determina qué valor específico retorna la función; solo determina el tipo
de ese valor.

La segunda: dentro de la función que retornará un valor necesitamos usar la
**declaración de retorno** para indicar el valor específico que retorna la función. El valor
específico que retorna una función se llama **valor de retorno**. Cuando se ejecuta una
declaración de retorno, el valor de retorno se pasa a la función que llamó a la otra. A este
proceso se le conoce como "**retornar por valor**".

Veamos un ejemplo de una función que retorna un valor entero:
```cpp
#include <iostream>
 
// int es el tipo del valor de retorno
// El tipo "int" de un valor de retorno quiere decir que la función retornará algún valor entero (aquí no se especifica el valor en sí)
int returnFive()
{
    // La declaración de retorno indica el valor específico que retornará la función
    return 5; // retorno del valor específico 5
}
 
int main()
{
    std::cout << returnFive() << '\n'; // imprime 5
    std::cout << returnFive() + 2 << '\n'; // imprime 7
 
    returnFive(); // bien: tenemos ahora el valor 5, pero es ignorado ya que main() no hace nada con él
 
    return 0;
}
```

Output del programa:
```
5
7
```

La ejecución de este programa comienza en la función main. En la primera declaración estamos
llamando a la función *returnFive*. Ésta retorna el valor específico 5, estando ahora
disponible para la función main.

En la segunda declaración estamos llamando a *returnFive* de nuevo. La función retorna el
valor específico 5 y éste forma parte del cálculo 5 + 2, produciendo el resultado 7.

En la tercera declaración estamos llamando de nuevo a la función *returnFive*, haciendo que
retorne el valor 5. No obstante, en este caso la función *main* no está haciendo nada con ese
valor, por lo que no ocurrirá más nada (se ignora el valor retornado).

Nota: los valores de retorno no se imprimirán a menos que la función que llama a la otra
función los envíe a la consola a través de std::cout. Como en el caso de la tercera
declaración de arriba no estamos usando std::cout, el valor no se imprimirá.

## Reparando nuestro programa

Habiendo aprendido esto, intentemos reparar el programa que escribimos al principio de la
lección:
```cpp
#include <iostream>
 
int getValueFromUser() // esta función retorna un valor entero
{
 	std::cout << "Escribe un entero: ";
	int input{};
	std::cin >> input;  
 
	return input; // retornar el valor que introdujo el usuario
}
 
int main()
{
	int num { getValueFromUser() }; // inicializar num con el valor que retorna getValueFromUser()
 
	std::cout << num << " el número multiplicado por 2 es: " << num * 2 << '\n';
 
	return 0;
}
```

Cuando se ejecuta este programa, la primera declaración de la función *main* creará una
variable de tipo entero llamada *num*. Cuando el programa inicializa *num* verá a la llamada
de función y la ejecutará. La función *getValueFromUser* le pide al usuario que introduzca un
valor y luego lo retorna. Este valor de retorno se usa como el valor de inicialización de la
variable *num*.

Compila este programa por ti mismo y ejecútalo unas cuantes veces si quieres comprobar por ti
mismo que funciona.

## Valores de retorno void

No es obligatorio que las funciones retornen un valor. Para indicarle al compilador que la
función no retorna ningún valor, usa la palabra reservada **void**. Veamos esta función
doPrint() de la lección anterior:
```cpp
void doPrint() // void es el tipo de retorno
{
    std::cout << "En doPrint()" << '\n';
    // Esta función no retorna un valor, por lo que no se necesita ninguna declaración de retorno
}
```

Esta función tiene un tipo de retorno void, indicando que no retorna ningún valor. Ya que
esta función no retorna ningún valor, no se necesita una declaración de retorno (si intentas
retornar un valor específico de una función con un tipo de retorno void resultará en un
error de compilación).

Aquí hay otro ejemplo de una función que retorna void:
```cpp
#include <iostream>
 
// "void" significa que la función no retorna ningún valor ("vacío" en español)
void returnNothing()
{
    std::cout << "Hola" << '\n';
    // Esta función no retorna ningún valor, por lo que no se necesita ninguna declaración de retorno
}
 
int main()
{
    returnNothing(); // bien: llamamos a la función returnNothing(), la cual no retorna ningún valor
 
    std::cout << returnNothing(); // error: esta línea no compilará; tendrás que comentarla
 
    return 0;
}
```

En la primera llamada de la función *returnNothing*, ésta imprime "Hola" y no retorna nada.
El programa vuelve a la función *main* y el programa continúa su ejecución.

La segunda llamada de función a *returnNothing* no compilará. La función *returnNothing*
tiene un tipo de retorno void, indicando que no retorna ningún valor. Sin emabrgo, esta
declaración trata de envair el valor de retorno de *returnNothing* a std::cout para luego ser
imprimido. std::cout no sabe cómo manejar esto (¿qué valor debería imprimir). Es por esto
que el compilador devolverá un error. La única opción que tienes es comentar esa línea de
código; así compilará tu programa.

Usamos este tipo de retorno cuando queremos indicar que una función no retorna nada (porque
no necesita hacerlo). En el ejemplo de arriba la función *returnNothing* tiene una
funcionalidad muy útil (imprime "Hola" en la consola) pero no necesita retornar un valor.
Es por eso que indicamos como "void" el tipo de retorno de la función *returnNothing*.

## Retornando de main

Ahora entiendes el funcionamiento de la función *main*. Cuando se ejecuta el programa, el
sistema operativo ejerce la funcionalidad de una función *main*. Luego, la ejecución del
programa salta al principio de la función *main*, ejecutándose posteriormente las
declaraciones de manera secuencial. Por último, *main* devuelve un valor entero (generalmente
0) y el programa termina de ejecutarse. Es común llamar **código de estado** al valor que
retorna la función *main* (algunos lo llaman también **código de término** o, raramente,
**código de retorno**). Este valor se utiliza para indicar si el programa se ejecutó
correctamente o no.

> **Mejores prácticas**
>
> La función *main* retorna el valor 0 si el programa se ejecutó correctamente.

Se usa un valor que no sea 0 para indicar que ocurrió un error (a pesar de que esto funciona
en la mayoría de los sistemas operativos, no es una garantía que sea portable).

> **Para lectores avanzados**
>
> El estándar de C++ define el concepto de 3 códigos de estado: 0, EXIT_SUCCESS y
> EXIT_FAILURE. Tanto 0 y EXIT_SUCCESS quieren decir que el programa se ejecutó de manera
> exitosa. EXIT_FAILURE quiere decir que el programa no se ejecutó de manera exitosa.
>
> EXIT_SUCCESS y EXIT_FAILURE están definidos en el encabezado <cstdlib>:
> ```cpp
> #include <cstdlib> // for EXIT_SUCCESS and EXIT_FAILURE
> 
> int main()
> {
>     return EXIT_SUCCESS;
> }
> ```
> Si quieres incrementar la portabilidad deberías usar 0 o EXIT_SUCCESS para indicar que
> el programa se ejecutó de manera exitosa. Usa EXIT_FAILURE para indicar que el programa se
> ejecutó de manera no exitosa.

C++ no permite que se llame a la función *main*.

Por ahora deberías definir la función *main* al final de tu archivo de código, debajo de
cualquier otra función.

## Notas adicionales sobre los valores de retorno

Si una función tiene un tipo de retorno que no es void, *debe* retornar un valor de ese tipo
(usando una declaración de retorno). Si no lo haces, obtendrás un comportamiento indefinido.
La única excepción de esat regla se aplica a la función main(), la cual asume que se retornará
un valor 0 a pesar de que no se indique explícitamente. Dicho esto, es mejor retornar
explícitamente un valor de main, tanto para ser explícito y para ser consistente en relación
a las otras functiones (las cuales no te dejarán omitir la declaración de retorno de valor).

> **Mejores prácticas**
>
> Siempre indica explícitamente un valor de retorno para cualquier función que tenga un tipo
> de retorno que no sea void.

> **Advertencias**
>
> Si no escribes una declaración de retorno en una función con un tipo de retorno que no es
> void (una función que no sea main), el programa tendrá un comportamiento indefinido.

Cuando se ejecuta una declaración de retorno, la función retorna el valor inmediatamente.
Cualquier código adicional en la función es ignorado.

Una función solo puede retornar un solo valor cuando es llamada. Sin embargo, el valor no
tiene que ser un valor literal, puede ser el resultado de alguna expresión, incluyendo una
variable o incluso una llamada a otra función que retorna un valor. En la función
*getValueFromUser()* que definimos arriba, retornamos una variable que almacena el número
que introdujo el usuario.

Es importante mencionar que una función puede definir qué significa el valor que retorna.
Algunas funciones usan valores de retorno como códigos de estado para indicar si el programa
se ejecutó satisfactoriamente o no. Otras funciones retornan valores provenientes de un
cálculo. Otras no retornan nada. El autor define el significado del valor que retorna una
función. Ya que hay una gran cantidad de probabilidades, es una buena idea declarar usando
un comentario qué significa el valor que retorna la función.

Por ejemplo:
```cpp
// La función le pide al usuario que escriba un valor
// El valor de retorno es el número entero que escribe el usuario
int getValueFromUser()
{
 	std::cout << "Escribe un entero: ";
	int input{};
	std::cin >> input;  
 
	return input; // valor de retorno que escribió el usuario
}
```

## Reutilizando funciones

Ahora podemos mostrar un buen uso de esta funcionalidad:
```cpp
#include <iostream>
 
int main()
{
	int x{};
	std::cout << "Escribe un entero: ";
	std::cin >> x; 
 
	int y{};
	std::cout << "Escribe un entero: ";
	std::cin >> y; 
 
	std::cout << x << " + " << y << " = " << x + y << '\n';
 
	return 0;
}
```

Este programa funciona, pero es un poco redundante. De hecho, este programa no cumple con
uno de los principios de la buena programación: "No te repitas" (abreviado a "DRY" desde
el inglés "Don't Repeat Yourself").

¿Por qué es malo repetir código? Bueno, imaginemos que queremos cambiar el texto
"Escribe un entero: " por algún otro; tendremos que cambiar este texto por cada vez que
aparece en el archivo de código. ¿Y si queremos inicializar 10 variables en vez de 2?
Si escribimos todo eso, nuestro programa tendría un montón de código redundante (haciendo
que sea más difícil de entender e incrementando la oportunidad que cometer un error al
escribir).

Vamos a actualizar el programa de arriba:
```cpp
#include <iostream>
 
int getValueFromUser()
{
 	std::cout << "Escribe un entero: ";
	int input{};
	std::cin >> input;  
 
	return input;
}
 
int main()
{
    int x{ getValueFromUser() }; // primera llamdada a getValueFromUser
    int y{ getValueFromUser() }; // primera llamdada a getValueFromUser
 
    std::cout << x << " + " << y << " = " << x + y << '\n';
 
    return 0;
}
```

Este programa produce el sigueinte resultado:
```
Escribe un entero: 5
Escribe un entero: 7
5 + 7 = 12
```

En este programa estamos llamando a la función *getValueFromUser* dos veces de inicializando
las variables *x* y *y* una sola vez respectivamente. Eso hace que no necesitemos escribir
código redundante, reduciendo las probabilidades de cometer un error. Ya que sabemos que
*getValueFromUser* funciona para una variable, funcionará para cualquier variable que
necesitemos.

Esta es la esencia de la programación modular: la posibilidad de crear una función, probarla
y asegurarnos de que funciona, podiendo reutilizarla cuantas veces queramos (siempre y
cuando no modifiquemos la función; si lo hacemos tendremos que volverla a probar).

> **Mejores prácticas**
>
> Sigue la práctica DRY: "No te repitas". Si necesitas hacer una misma cosa más de una sola
> vez, considera la modificación de tu código para remover la mayor cantidad de código
> redundante. Las variables pueden ser usadas para almacenar los resultados de las
> operaciones que se necesitan usar más de una vez (para no tener que repetir una porción
> de código). Las funciones se pueden usar para definir una secuencia de declaraciones
> que queremos ejecutar más de una vez. Y los bucles (de los cuales hablaremos en una
> próxima lección) pueden ser usados para ejecutar una declaración más de una vez.

## Conclusión

Los valores de retorno nos ayudan a retornar un solo valor de una función.

Las funciones nos ayudan a hacer que nuestro código sea menos redundante.

## Prueba

**Pregunta 1**

Lee los próximos programas y determina cuál será su output (si es que compilan; si no,
determina que no compilará).

a)

```cpp
#include <iostream>
 
int return7()
{
    return 7;
}
 
int return9()
{
    return 9;
}
 
int main()
{
    std::cout << return7() + return9() << '\n';
 
    return 0;
}
```

<details>
    <summary>Mostrar solución</summary>
    Este programa imprime el número 16.
</details>

b)

```cpp
#include <iostream>
 
int return7()
{
    return 7;
 
    int return9()
    {
        return 9;
    }
}
 
int main()
{
    std::cout << return7() + return9() << '\n';
 
    return 0;
}
```

<details>
    <summary>Mostrar solución</summary>
    Este programa no compilará. No se permiten las funciones anidadas.
</details>

c)

```cpp
#include <iostream>
 
int return7()
{
    return 7;
}
 
int return9()
{
    return 9;
}
 
int main()
{
    return7();
    return9();
 
    return 0;
}
```

<details>
    <summary>Mostrar solución</summary>
    Este programa compila pero no produce ningún output. Los valores de retorno de las funciones no se están usando para nada (por lo tanto, son descartadas).
</details>

d)

```cpp
#include <iostream>
 
void printA()
{
    std::cout << "A\n";
}
 
void printB()
{
    std::cout << "B\n";
}
 
int main()
{
    printA();
    printB();
 
    return 0;
}
```

<details>
    <summary>Mostrar solución</summary>
    Este programa imprime las letras A y B en líneas separadas.
</details>

e)

```cpp
#include <iostream>
 
void printA()
{
    std::cout << "A\n";
}
 
int main()
{
    std::cout << printA() << '\n';
 
    return 0;
}
```

<details>
    <summary>Mostrar solución</summary>
    Este programa no compilará. La función printA() retorna void, mientras de main() intenta enviar este valor usando std::cout. Esto producirá un error de compilación.
</details>

f)

```cpp
#include <iostream>
 
int getNumbers()
{
    return 5;
    return 7;
}
 
int main()
{
    std::cout << getNumbers() << '\n';
    std::cout << getNumbers() << '\n';
 
    return 0;
}
```

<details>
    <summary>Mostrar solución</summary>
    Este programa imprime 5 dos veces (en líneas separadas). Cuando se llama a la función
    getNumbers(), se devuelve el valor 5. Cuando se ejecuta la declaración de retorno, la función para de ejecutarse inmediatamente, por lo que la declaración de retorno que retorna 7 nunca se ejecuta.
</details>

g)

```cpp
#include <iostream>
 
int return 5()
{
    return 5;
}
 
int main()
{
    std::cout << return 5() << '\n';
 
    return 0;
}
```

<details>
    <summary>Mostrar solución</summary>
    Este programa no compilará porque la función tiene un nombre que no es válido. Hablamos sobre las reglas de los nombres en la <a href="/Contenido/Cap%C3%ADtulo%2000%20Introducci%C3%B3n%20-%20Empezando/00.07%20Compilando%20tu%20primer%20programa.md">lección 00.07</a>.
</details>

h) Extra

```cpp
#include <iostream>
 
int returnFive()
{
    return 5;
}
 
int main()
{
    std::cout << returnFive << '\n';
 
    return 0;
}
```

<details>
    <summary>Mostrar solución</summary>
    Este programa compilará pero la función no se llamará porque la llamada a la función no tiene paréntesis. Dependiendo del compilador imprimirá un valor diferente.
</details>

**Pregunta 2**

¿Qué significa "DRY" y por qué es útil seguir esta práctica?

<details>
    <summary>Mostrar solución</summary>
    DRY quiere decir "Don't Repeat Yourself" ("No te repitas" en español). Esta práctica implica escribir tu código para evitar que minimices la redundancia de tu programa. Esto hace que tus programas sean más concisos, tengan menos errores y sea más fácil mantenerlos.
</details>

---

**[Lección anterior](/Contenido/Cap%C3%ADtulo%2002%20Fundamentos%20de%20C%2B%2B%20-%20Funciones%20y%20archivos/02.01%20Introducci%C3%B3n%20a%20las%20funciones.md)** - **[Contenido](https://github.com/JoseDeFreitas/learncpp.es#contenido)** - **[Lección siguiente](/Contenido/Cap%C3%ADtulo%2002%20Fundamentos%20de%20C%2B%2B%20-%20Funciones%20y%20archivos/02.03%20Introducci%C3%B3n%20a%20los%20par%C3%A1metros%20y%20argumentos%20de%20las%20funciones.md)**