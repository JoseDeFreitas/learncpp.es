# 02.06 Declaraciones y definiciones de futuro

<details>
    <summary>Información del archivo</summary>

| Autor en inglés | Traductor al español | Fecha de creación | Última modificación |
| --------------- | -------------------- | ----------------- | ------------------- |
| Alex            | José De Freitas      | 02/06/2007        | 26/12/2020          |

</details>

El siguiente programa es presuntamente inocente:
```cpp
#include <iostream>
 
int main()
{
    std::cout << "La suma de  3 y 4 es: " << add(3, 4) << '\n';
    return 0;
}
 
int add(int x, int y)
{
    return x + y;
}
```

Seguramente esperarías que el output de este programa sea:
```
La suma de  3 y 4 es: 7
```

Pero, en realidad, ¡este programa no compila! Visual Studio produce el siguiente error de
compilación:
```
add.cpp(5) : error C3861: 'add': identifier not found
```

La razón del error de compilación de este programa es que el compilador compila el contenido
de los archivos de código de manera secuencial. Cuando el compilador llega a la llamada a la
función *add* en la línea 5 de la función *main* este no sabe qué es *add* ya que definimos
la función *add* en la línea 9. Específicamente, el error que produce es *identifier not found*.

Las versiones más antiguas de Visual Studio producirán un error adicional:
```
add.cpp(9) : error C2365: 'add' : redefinition; previous definition was 'formerly unknown identifier'
```

Esto es algo confuso teniendo en cuenta que *add* nunca fue definido. A pesar de esto es útil
notar que es bastante común que se produzcan errores redundantes o relacionados al igual que
advertencias a partir de un error principal.

> **Mejores prácticas**
>
> Cuando vayas a resolver errores de compilación en tus programas asegúrate de resolver el
> primer error producido y compilar nuevamente.

Para arreglar este problema necesitamos tener en cuenta que el compilador no sabe qué es
*add*. Hay dos maneras comunes de solucionar este problema.

#### **Índice**

1. [Opción 1: reordenar las definiciones de funciones](#opción-1-reordenar-las-definiciones-de-funciones)
2. [Opción 2: usar una declaración de futuro](#opción-2-usar-una-declaración-de-futuro)
3. [Obviando el cuerpo de la función](#obviando-el-cuerpo-de-la-función)
4. [Otros tipos de declaraciones de futuro](#otros-tipos-de-declaraciones-de-futuro)
5. [Declaraciones vs. definiciones](#declaraciones-vs-definiciones)
6. [Prueba](#prueba)

## Opción 1: reordenar las definiciones de funciones

Una manera de solucionar este problema es reordenar las definiciones de la función para que
*add* sea definida antes de *main*:
```cpp
#include <iostream>
 
int add(int x, int y)
{
    return x + y;
}
 
int main()
{
    std::cout << "La suma de  3 y 4 es: " << add(3, 4) << '\n';
    return 0;
}
```

De esta manera el compilador ya sabe qué es *add* a la hora de ser llamada dentro de *main*.
Debido a la simplicidad de este programa el cambio que acabamos de ver es fácil de entender.
Sin embargo puede llegar a ser tedioso entender qué funciones llaman a qué funciones (y en
qué orden lo hacen) si estamos trabajando en un programa más grande.

Además, no siempre podemos hacer esto. Imaginemos que estamos escribiendo un programa que
tiene dos funciones, *A* y *B*. *A* llama a *B* y *B* llama a *A*. En este caso no hay una
forma de ordenar las funciones de manera que el compilador no se queje. Si defines *A* primero
el compilador no hará su trabajo ya que no sabe qué es *B*. Así mismo, si defines *B* primero
el compilador no hará su trabajo ya que no sabe qué es *A*.

## Opción 2: usar una declaración de futuro

También podemos solucionar este error usando una declaración de futuro.

Una **declaración de futuro** nos permite indicarle al compilador de la existencia de un
identificador *antes* de definir el identificador.

En el caso de las funciones podemos indicarle al compilador sobre la existencia de una
función antes de definir el cuerpo de la función. Así el compilador encontrará la llamada a la
función entendiendo que es, efectivamente, una llamada a una función, y dándose cuenta de que
estamos llamando a la función de manera correcta, incluso si el compilador no sabe cómo o
dónde está definida la función.

Para escribir una declaración de futuro para una función debemos usar una declaración llamada
**prototipo de función**. El prototipo de función consiste en el tipo de valor de retorno de
la función, el nombre y los parámetros pero con la diferencia de la ausencia del cuerpo de la
función (las llaves y todas las declaraciones dentro de ellas), terminadas con un punto y coma.

Aquí puedes ver un prototipo de función para la función *add*:
```cpp
int add(int x, int y); // el propotipo de la función incluye el tipo de valor de retorno, el nombre, los parámetros y el punto y coma. ¡No está el cuerpo de la función!
```

Ahora veamos el programa que no compilaba anteriormente pero usando ahora un prototipo de
función como una declaración de futuro para la función *add*:
```cpp
#include <iostream>
 
int add(int x, int y); // declaración de futuro de add() (usando un prototipo de función)
 
int main()
{
    std::cout << "La suma de  3 y 4 es: " << add(3, 4) << '\n'; // esto funciona porque usamos una declaración de futuro a add() arriba
    return 0;
}
 
int add(int x, int y) // a pesar de que el cuerpo de add() no está definido antes de esta parte
{
    return x + y;
}
```

Ahora, cuando el compilador llegue a la llamada a la función *add* en *main*, sabrá qué es
*add* (una función que toma dos parámetros de tipo entero y retorna un valor de tipo entero) y
no obtendremos ningún error.

Es importante aclarar que no es necesario especificar los nombres de los parámetros en los
prototipos de función. En el código de arriba también puedes escribir la declaración de
futuro de la siguiente manera:
```cpp
int add(int, int); // prototipo de función válido
```

No obstante es preferible nombrar los parámetros (usando los mismos nombres definidos en
la función) porque podemos entender más fácilmente cuáles son los parámetros de la función
con solo mirar el prototipo de función. Si no haces esto tendrás que localizar la declaración
de la función.

> **Mejores prácticas**
>
> A la hora de definir prototipos de función haz que los nombres de los parámetros coincidan.
> Puedes crear declaraciones de futuro copiando y pegando desde la declaración de la función.
> No olvides el punto y coma al final de la declaración.

## Obviando el cuerpo de la función

Los programadores novatos se preguntan qué ocurriría si usan una declaración de futuro sin
haber definido la función en sí.

La respuesta es: depende. Si usas una declaración de futuro pero nunca se llama a la función
el programa compilará y se ejecutará perfectamente. Pero, si se usa la declaración de función
y se llama a la función pero la función en sí no está definida en el programa la compilación
funcionará, pero el enlace devolverá un error ya que no puede hacer nada con la llamada a la
función

Analiza en siguiente programa:
```cpp
#include <iostream>
 
int add(int x, int y); // declaración de futuro a add() usando un prototipo de función
 
int main()
{
    std::cout << "La suma de  3 y 4 es: " << add(3, 4) << '\n';
    return 0;
}
 
// Nota: no hay una definición de la función add
```

En este programa estamos usando una declaración de futuro a la función *add* y estamos
llamando a *add*, pero no estamos definiendo *add* en ningún lugar. Cuando intentamos compilar
este programa, Visual Studio produce el siguiente mensaje:
```
Compiling...
add.cpp
Linking...
add.obj : error LNK2001: unresolved external symbol "int __cdecl add(int,int)" (?add@@YAHHH@Z)
add.exe : fatal error LNK1120: 1 unresolved externals
```

Como ves, el programa ha compilado exitosamente, pero ha fallado el enlace ya que
*int add(int, int)* nunca fue definido.

## Otros tipos de declaraciones de futuro

Las declaraciones de futuro son usadas con funciones, la mayoría de las veces. Sin embargo,
las declaraciones de futuro también pueden ser usadas con otros identificadores de C++, como
las variables y los tipos definidos por el usuario. Las variables y los tipos definidos por el
usuario tienen una sintaxis diferente a la hora de usarlos junto con una declaración de
futuro, por lo que veremos estas en lecciones futuras.

## Declaraciones vs. definiciones

Seguramente verás que las palabras "declaración" y "definición" son usadas indistintamente en
C++. ¿Qué significan realmente estas palabras? Ahora tienes el conocimiento suficiente para
entender la diferencia entre estas dos.

Una **definición** implementa (para las funciones y los tipos) o instancia (para las
variables) el identificador. Aquí puedes ver unos ejemplos de definiciones:
```cpp
int add(int x, int y) // implementa la función add()
{
    int z{ x + y }; // instancia la variable z
 
    return z;
}
```

Se necesita una definición para satisfacer al *enlace*. Si usas un identificador sin una
definición el *enlace* devolverá un error.

La **regla de una definición** ("ODR - One Definition Rule", por sus siglas en inglés) es una
regla muy conocida de C++. La ODR tiene tres partes:
1. Dentro de un *archivo* una función, un objeto, un tipo o una plantilla solo puede haber una
definición.
2. Dentro de un *programa* un objeto o una función normal solo puede haber una definición.
Esta distinción existe porque los programas pueden tener más de un archivo (te enseñaremos
sobre esto en la siguiente lección).
3. Los tipos, las plantillas, las funciones de una línea y las variables pueden tener
definiciones idénticas en archivos diferentes. Aún no te hemos enseñado qué son estas cosas,
así que no te preocupes sobre esto por ahora; te lo explicaremos cuando sea necesario.

No cumplir con el punto 1 de la ODR hará que el compilador devuelva un error. No cumplir con
el punto 2 de la ODR probablemente hará que el enlace devuelva un error. No cumplir con el
punto 3 de la ODR hará que el programa actúe de forma indefinida.

Aquí hay un ejemplo de un incumplimiento del punto 1 de la ODR:
```cpp
int add(int x, int y)
{
     return x + y;
}
 
int add(int x, int y) // incumplimiento de la ODR; ya hemos definido la función add
{
     return x + y;
}
 
int main()
{
    int x;
    int x; // incumplimiento de la ODR; ya hemos definido x
}
```

Ya que el programa no cumple con el punto 1 de la ODR, el compilador de Visual Studio
devolverá los siguientes errores de compilación:
```
project3.cpp(9): error C2084: function 'int add(int,int)' already has a body
project3.cpp(3): note: see previous definition of 'add'
project3.cpp(16): error C2086: 'int x': redefinition
project3.cpp(15): note: see declaration of 'x'
```

> **Para lectores avanzados**
>
> Las funciones que comparten un identificador pero tienen parámetros diferentes son
> consideradas como funciones diferentes. Discutiremos sobre esto en la [lección 10.07](/Contenido/Cap%C3%ADtulo%2010%20Funciones/10.07%20Sobrecarga%20de%20funciones.md)

Una **declaración** es una sentencia que le dice al *compilador* sobre la existencia de un
identificador y el tipo de su información. Aquí hay algunos ejemplos de declaraciones:
```cpp
int add(int x, int y); // le dice al compilador sobre la función llamada "add", que toma dos parámetros de tipo entero y retorna un valor de tipo entero. ¡No se define el cuerpo!
int x; // le dice al compilador sobre la variable de tipo entero llamada x
```

Una declaración es todo lo que necesitamos para satisfacer al compilador. Es por esto que
podemos usar una declaración de futuro para decirle al compilador sobre la declaración
de identificación definida después.

En C++ todas las definiciones sirven como declaraciones. Es por esto que *int x* aparece en
nuestros ejemplos para ambas definiciones y declaraciones. Ya que *int x* es una definición,
es, por consiguiente, una declaración. En la mayoría de los casos las definiciones son
útiles para nuestros objetivos ya que satisfacen al compilador y al enlazador. Solo
necesitamos escribir una declaración explícita cuando querramos usar un identificador antes
de la definición.

Es cierto que todas las definiciones son también declaraciones; sin embargo, lo contrario no
es cierto: todas las declaraciones no son definiciones. Un ejemplo de este caso es el
prototipo de función; este satisface al compilador pero no al enlazador. Las declaraciones
que no son definiciones son llamadas **declaraciones puras**. Otros tipos de declaraciones
puras incluyen: declaraciones de futuro para variables y declaraciones de tipo (las
encontrarás en lecciones posteriores, no te preocupes por ellas por ahora).

La ODR no aplica para las declaraciones puras (es la *regla de una definición*, no la
*regla de una declaración*), por lo que puedes tener tantas declaraciones puras para un
identificador como desees (aunque si tienes más de una haría tu código redundante).

> **Nota del autor**
>
> En el lenguaje general el término "declaración" es usado comúnmente para referirse a una
> "declaración pura" y el término "definición" para referirse a "una definición que también
> es una declaración". Es por eso que se llama definición a *int x;*, a pesar que que es
> tanto una definición como una declaración.

## Prueba

**Pregunta 1**

¿Qué es un prototipo de función?

<details>
    <summary>Mostrar solución</summary>
    Un prototipo de función es una sentencia de declaración que incluye el nombre de la función, el tipo del valor de retorno y los parámetros. No incluye el cuerpo de la función.
</details>

**Pregunta 2**

¿Qué es una declaración de futuro?

<details>
    <summary>Mostrar solución</summary>
    Una declaración de futuro le indica al compilador que un identificador existe antes de ser definido.
</details>

**Pregunta 3**

¿Cómo se declara una declaración de futuro para las funciones?

<details>
    <summary>Mostrar solución</summary>
Para las funciones, los prototipos de función sirven como una declaración de futuro.

Para otros tipos de identificadores (como variables y tipos definidos por el usuario) hay una sintaxis diferente de declaración de futuro.
</details>

**Pregunta 4**

Escribe el prototipo de función para esta función (usa la forma preferida, que usa nombres):
```cpp
int doMath(int first, int second, int third, int fourth)
{
     return first + second * third / fourth;
}
```

<details>
    <summary>Mostrar solución</summary>

    // No te olvides del punto y coma al final, ya que esta esta una declaración.
    int doMath(int first, int second, int third, int fourth);

</details>

**Pregunta 5**

Determina, para cada programa, si fallarán a la hora de compilar, de enlazar, de compilar y enlazar o si compilará y enlazará de manera exitosa. Si no estás seguro, ¡compílalo!

a)

```cpp
#include <iostream>
int add(int x, int y);
 
int main()
{
    std::cout << "3 + 4 + 5 = " << add(3, 4, 5) << '\n';
    return 0;
}
 
int add(int x, int y)
{
    return x + y;
}
```

<details>
    <summary>Mostrar solución</summary>
    No compila. El compilador indicará que la llamada a la función add() en main() no tiene el mismo número de parámetros que la que está en la declaración de futuro.
</details>

b)

```cpp
#include <iostream>
int add(int x, int y);
 
int main()
{
    std::cout << "3 + 4 + 5 = " << add(3, 4, 5) << '\n';
    return 0;
}
 
int add(int x, int y, int z)
{
    return x + y + z;
}
```

<details>
    <summary>Mostrar solución</summary>
    No compila. El compilador indicará que no puede encontrar una función add() que toma 3 argumentos ya que la función add() tiene solo 2 argumentos en la declaración de futuro.
</details>

c)

```cpp
#include <iostream>
int add(int x, int y);
 
int main()
{
    std::cout << "3 + 4 + 5 = " << add(3, 4) << '\n';
    return 0;
}
 
int add(int x, int y, int z)
{
    return x + y + z;
}
```

<details>
    <summary>Mostrar solución</summary>
    No enlazará. El compilador referenciará el prototipo de la declaración de futuro de la función add() a la llamada de función a add() en main(). No obstante, la función add() que toma 2 parámetros nunca fue implementada (solo implementamos una que toma 3 parámetros), por lo que el enlazador no hará su trabajo.
</details>

d)

```cpp
#include <iostream>
int add(int x, int y, int z);
 
int main()
{
    std::cout << "3 + 4 + 5 = " << add(3, 4, 5) << '\n';
    return 0;
}
 
int add(int x, int y, int z)
{
    return x + y + z;
}
```

<details>
    <summary>Mostrar solución</summary>
    Compila y enlaza. La llamada a la función add() referencia el prototipo de la declaración de futuro, al igual que la función escrita.
</details>

---

**[Lección anterior](/Contenido/Cap%C3%ADtulo%2002%20Fundamentos%20de%20C%2B%2B%20-%20Funciones%20y%20archivos/02.05%20El%20porqu%C3%A9%20de%20la%20utilidad%20de%20las%20funciones%20y%20c%C3%B3mo%20usarlas%20efectivamente.md)** - **[Contenido](https://github.com/JoseDeFreitas/learncpp.es#contenido)** - **[Lección siguiente](/Contenido/Cap%C3%ADtulo%2002%20Fundamentos%20de%20C%2B%2B%20-%20Funciones%20y%20archivos/02.07%20Programas%20con%20varios%20archivos%20de%20c%C3%B3digo.md)**