# 01.04 Asignación e inicialización de variables

<details>
    <summary>Información del archivo</summary>

| Autor en inglés | Traductor al español | Fecha de creación | Última modificación |
| --------------- | -------------------- | ----------------- | ------------------- |
| Alex            | José De Freitas      | 01/02/2019        | 22/03/2021          |

</details>

En la [lección 01.03](/Contenido/Cap%C3%ADtulo%2001%20Fundamentos%20de%20C%2B%2B/01.03%20Introducci%C3%B3n%20a%20las%20variables.md)
te enseñamos a cómo definir una variable para almacenar valores. En esta lección exploraremos
cómo almacenar valores dentro de variables y cómo hacer uso de esos valores.

Como recordatorio aquí te enseñamos una pequeña porción de código que define una variable
de tipo entero llamada *x* y luego dos variables más de tipo entero llamadas *y* y *z*:
```cpp
int x; // define una variable de tipo entero llamada x
int y, z; // define dos variables de tipo entero llamadas y y z
```

#### **Índice**

1. [Asignación de variables](#asignación-de-variables)
2. [Copia e inicialización directa](#copia-e-inicialización-directa)
3. [Inicialización de lista](#inicialización-de-lista)
4. [Inicializa tus variables](#inicializa-tus-variables)
5. [Inicializando múltiples variables](#inicializando-múltiples-variables)
6. [Prueba](#prueba)

## Asignación de variables

Puedes asignarle un valor a la variable (en una declaración separada) luego de haberla
definido usando el *operador* =. Este proceso se llama **asignación de copia** (o simplemente
**asignación**).

```cpp
int width; // define una variable de tipo entero llamada width
width = 5; // asignación de copia del valor 5 dentro de la variable width
 
// la variable width tiene ahora el valor 5
```

La asignación de copia se llama de esta manera ya que su función es copiar el valor de la
derecha del *operador* = a la variable en la parte izquierda del operador. El *operador* = se
llama "**operador de asignación**.

Aquí hay un ejemplo en donde asignamos dos veces:
```cpp
#include <iostream>
 
int main()
{
	int width;
	width = 5; // asignación de copia del valor 5 dentro de la variable width
 
	// la variable width tiene ahora el valor 5
 
	width = 7; // cambiar el valor almacenado en la variable width por 7
 
	// la variable width tiene ahora el valor 7
 
	return 0;
}
```

Cuando asignamos el valor 7 a la variable *width*, el valor 5 que estaba almacenado
previamente se sobrescribe. Las variables normales pueden almacenar solo un valor por vez.

> **Advertencias**
>
> Uno de los errores más comunes que cometen los programadores nuevos es confundir el operador
> de asignación (=) con el operador de igualdad (==). El operador de asignación (=) se utiliza
> para asignarle a la variable un valor. El operador de igualdad (==) se utiliza para
> comprobar si el valor de dos operandos es igual.

## Copia e inicialización directa

Una desventaja de la asignación es que requiere al menos dos declaraciones: una para definir
la variable y otra para asignarle el valor.

Por suerte, podemos combinar estas dos declaraciones. Cuando definimos una variable podemos
asignarle directamente un valor al mismo tiempo. Esto se llama **inicialización**.

C++ soporta tres maneras básicas de inicializar una variable. Primero, podemos hacer una
**asignación de copia** usando un símbolo de igualdad:
```cpp
int width = 5; // inicialización de copia del valor 5 dentro de la variable width
```

Muy parecido a la asignación de copia, esta porción de código copia el valor del lado derecho
del signo de igual a la variable que está siendo creada en el lado izquierdo.

También podemos hacer una **inicialización directa** usando paréntesis:
```cpp
int width( 5 ); // inicialización directa del valor 5 dentro de la variable width
```

Para tipos de datos simples (como los enteros) la inicialización de copia y la inicialización
directa son esencialmente las mismas. Veremos las diferencias entre ellas más tarde.

Por último, podemos hacer la inicialización de lista, la cual veremos en la siguiente sección.

## Inicialización de lista

Desafortunadamente, la inicialización directa (con paréntesis) no puede ser usada para todos
los tipos de inicialización (como inicializar un objeto con una lista de datos). Para
inicializar una variable de manera más consistente podemos usar la **inicialzación de lista**
(también llamada **inicialización uniforme** o **inicialización de llave**) que utiliza
llaves.

La inicialización de lista puede ser representada de dos maneras:
```cpp
int width{ 5 }; // inicialización de lista directa del valor 5 dentro de la variable width (recomendable)
int height = { 6 }; // inicialización de lista de copia del valor 6 dentro de la variable height
```

Ambas formas son casi idénticas, pero es más recomendable usar la forma directa.

Si inicializamos una variable con llaves vacías esto indica una inicialización de valor. En
la mayoría de los casos, la **inicialización de valor** inicializará la variable a 0 (o a un
valor vacío si es más apropiado para un tipo de dato en concreto). En casos en donde se le
asigna el valor 0 a una variable, la *inicialización de valor* es también llamada
**inicialización de ceros**:
```cpp
int width{}; // inicialización de valor a 0
```

La inicialización de lista tiene la ventaja de deshabilitar las conversiones "limitadas".
Esto significa que si intentas usar la inicialización de lista para inicializar una variable
con un valor que no está almacenado de manera segura, el compilador devolverá una advertencia
o un error. Por ejemplo:
```cpp
int width{ 4.5 }; // error: no todos los valores double caben dentro de un int
```

En la porción de código de arriba estamos intentando asignar un número (4.5) que tiene un
decimal (.5) a una variable de tipo entero (la cual solo puede almacenar números sin
decimales). La inicialización de copia y la inicialización directa descartarán el decimal,
haciendo que se inicialice la variable *width* al valor 4. Sin embargo, con la inicialización
de lista, podremos ver que el compilar nos devuelve un error (lo cual es generalmente algo
bueno ya que no querremos perder datos). Se permiten las conversiones que no descartan
datos.

> **Mejores prácticas**
>
> Usa la inicialización de lista directa siempre que puedas.

> **C++ permite las inicializaciones de lista de copia y directa, además de la asignación de copia. ¿Hay asignación directa o de lista?**
>
> No. C++ no soporta la sintaxis para una asignación directa o de lista.

> **¿Cuándo debo inicializar una variable con { 0 } en vez de con {}?**
>
> Usa una inicialización de valor explícita si estás usando ese valor exacto:
> ```cpp
> int x { 0 }; // inicialización de valor explícita a 0
> std::cout << x; // aquí usamos ese valor 0
> ```
> Usa una inicialización de valor si es valor es temporal y será reemplazado:
> ```cpp
> int x{}; // inicialización de valor
> std::cin >> x; // aquí reemplzamos el valor inmediatamente
> ```

## Inicializa tus variables

Inicializa tus variables al crearlas. Puede que encuentres casos en donde querrás ignorar
este consejo por una razón específica (por ejemplo: una sección del código de rendimiento
crítico que usa un montón de variables), y esto está bien, siempre y cuando la decición se
haga deliberadamente.

Para más información sobre este tema, Bjarne Stroustrup (creador de C++) y Herb Sutter
(experto en C++) hacen [esta recomendación](https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#es20-always-initialize-an-object).

Exploraremos qué ocurre si intentas usar una variable que no tiene un valor definido en la
[lección 01.06](/Contenido/Cap%C3%ADtulo%2001%20Fundamentos%20de%20C%2B%2B/01.06%20Variables%20no%20inicializadas%20y%20comportamientos%20no%20definidos.md).

> **Mejores prácticas**
>
> Inicializa tus variables al crearlas.

## Inicializando múltiples variables

En la lección previa te enseñamos que es posible definir muchas variables *del mismo tipo* en
una sola declaración separando los nombres con una coma:
```cpp
int a, b;
```

También te enseñamos que las mejores prácticas es evitar esta forma de hacerlo. No obstante,
ya que es posible que encuentres código que use esta forma de asignación, es útil hablar un
poco más sobre esto para reforzar algunas de las razones de por qué debes evitar esto.

Puedes inicializar múltiples variables definidas en la misma línea:
```cpp
int a = 5, b = 6; // inicialización de copia
int c( 7 ), d( 8 ); // inicialización directa
int e{ 9 }, f{ 10 }; // inicialización de lista (recomendable)
```

Desafortunadamente hay un error común que puede cometer el programador cuando intenta
inicializar ambas variables usando una sola declaración de inicialización:
```cpp
int a, b = 5; // incorrecto (¡a no está inicializada!)
 
int a = 5, b = 5; // correcto
```

En la declaración superior vemos que la variable "a" no fue inicializada y puede que el
compilador devuelve una advertencia. Si no lo hace, esta es una buena manera de que tu
programa falle intermitentemente y produzca resultados esporádicos. Pronto escribiremos más
sobre qué ocurre si usas variables no inicializadas.

La mejor manera de recordar cuál es el error es considerar el caso de una inicialización
directa o de lista:
```cpp
int a, b( 5 );
int c, d{ 5 };
```

Esto hace que sea más claro que el valor 5 está siendo usado para inicializar la variable
*b* o *d*, no *a* o *c*.

## Prueba

**Pregunta 1**

¿Cuál es la diferencia entre inicialización y asignación?

<details>
    <summary>Mostrar solución</summary>
    La inicialización hace que la variable tenga un valor inicial cuando ésta es creada. La asignación le da a la variable un valor en algún punto después de que la variable es creada.
</details>

**Pregunta 2**

¿Qué tipo de inicialización deberías usar?

<details>
    <summary>Mostrar solución</summary>
    Inicialización de lista directa.
</details>

---

**[Lección anterior](/Contenido/Cap%C3%ADtulo%2001%20Fundamentos%20de%20C%2B%2B/01.03%20Introducci%C3%B3n%20a%20las%20variables.md)** - **[Contenido](https://github.com/JoseDeFreitas/learncpp.es#contenido)** - **[Lección siguiente](/Contenido/Cap%C3%ADtulo%2001%20Fundamentos%20de%20C%2B%2B/01.05%20Introducci%C3%B3n%20a%20iostream%20-%20cout%2C%20cin%20y%20endl.md)**